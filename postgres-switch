#!/usr/bin/env python3
import argparse
import contextlib
import fcntl
import json
import os
import re
import shutil
import subprocess
import sys
import tempfile

CONFIG_PATH = os.path.expanduser("~/.postgres-switch.json")
CONFIG_VERSION = 1
REQUIRED_COMMANDS = ("pg_dump", "psql")
CONNECTION_ARGS = {}
MAINTENANCE_DB = "postgres"
DB_NAME_MAX_LEN = 63
BRANCH_NAME_PATTERN = re.compile(r"^[A-Za-z0-9_-]+$")
LOCK_DIR = os.path.expanduser("~/.postgres-switch-locks")


def load_config():
    if not os.path.exists(CONFIG_PATH):
        return {"version": CONFIG_VERSION, "databases": {}}
    with open(CONFIG_PATH, "r", encoding="utf-8") as f:
        data = json.load(f)
    if "databases" not in data:
        data["databases"] = {}
    if "version" not in data:
        data["version"] = CONFIG_VERSION
    return data


def save_config(config):
    config_dir = os.path.dirname(CONFIG_PATH) or "."
    os.makedirs(config_dir, exist_ok=True)
    with tempfile.NamedTemporaryFile(
        "w", encoding="utf-8", dir=config_dir, delete=False
    ) as tf:
        json.dump(config, tf, indent=2, ensure_ascii=False)
        tf.flush()
        os.fsync(tf.fileno())
        temp_path = tf.name
    os.replace(temp_path, CONFIG_PATH)


def lock_name_for_database(database):
    safe = re.sub(r"[^A-Za-z0-9_.-]", "_", database)
    return os.path.join(LOCK_DIR, f"{safe}.lock")


@contextlib.contextmanager
def database_lock(database):
    os.makedirs(LOCK_DIR, exist_ok=True)
    lock_path = lock_name_for_database(database)
    with open(lock_path, "w", encoding="utf-8") as lf:
        try:
            fcntl.flock(lf.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
        except BlockingIOError:
            raise RuntimeError(
                f"{database} は他の postgres-switch プロセスで処理中です。完了後に再実行してください。"
            )
        try:
            yield
        finally:
            fcntl.flock(lf.fileno(), fcntl.LOCK_UN)


def qident(name):
    return '"' + name.replace('"', '""') + '"'


def qstr(value):
    return "'" + value.replace("'", "''") + "'"


def branch_db_name(database, branch):
    return f"{database}__{branch}"


def validate_branch_name(database, branch):
    if not branch:
        raise ValueError("ブランチ名は必須です。")
    if not BRANCH_NAME_PATTERN.fullmatch(branch):
        raise ValueError(
            "ブランチ名に使用できる文字は英数字、ハイフン(-)、アンダースコア(_)のみです。"
        )
    snapshot = branch_db_name(database, branch)
    if len(snapshot.encode("utf-8")) > DB_NAME_MAX_LEN:
        raise ValueError(
            f"退避DB名が長すぎます: {snapshot} (最大 {DB_NAME_MAX_LEN} バイト)"
        )


def psql_client_args(params):
    args = []
    if params.get("host"):
        args.append(f"--host={params['host']}")
    if params.get("port"):
        args.append(f"--port={params['port']}")
    if params.get("user"):
        args.append(f"--username={params['user']}")
    return args


def run_psql(sql, database=MAINTENANCE_DB):
    params = CONNECTION_ARGS
    env = os.environ.copy()
    if params.get("password"):
        env["PGPASSWORD"] = params["password"]

    cmd = [
        "psql",
        *psql_client_args(params),
        f"--dbname={database}",
        "-v",
        "ON_ERROR_STOP=1",
        "-X",
        "-q",
        "-t",
        "-A",
        "-F",
        "\t",
        "-c",
        sql,
    ]
    result = subprocess.run(cmd, env=env, capture_output=True, text=True)
    if result.returncode != 0:
        stderr = result.stderr.strip() or "psql コマンド実行に失敗しました。"
        raise RuntimeError(stderr)
    return result.stdout


def ensure_required_commands():
    missing = [cmd for cmd in REQUIRED_COMMANDS if shutil.which(cmd) is None]
    if missing:
        missing_list = ", ".join(missing)
        raise RuntimeError(
            f"必須コマンドが見つかりません: {missing_list}。PostgreSQL クライアントツールをインストールしてください。"
        )


def db_exists(database):
    out = run_psql(f"SELECT 1 FROM pg_database WHERE datname = {qstr(database)}")
    return bool(out.strip())


def get_optional_pg_database_columns():
    out = run_psql(
        "SELECT attname FROM pg_attribute "
        "WHERE attrelid = 'pg_database'::regclass "
        "AND attname IN ('datlocprovider', 'daticulocale') "
        "AND NOT attisdropped"
    )
    return {line.strip() for line in out.splitlines() if line.strip()}


def get_db_defaults(database):
    optional_cols = get_optional_pg_database_columns()
    select_items = [
        "pg_encoding_to_char(d.encoding)",
        "d.datcollate",
        "d.datctype",
        "r.rolname",
        "t.spcname",
    ]
    if "datlocprovider" in optional_cols:
        select_items.append("d.datlocprovider")
    if "daticulocale" in optional_cols:
        select_items.append("COALESCE(d.daticulocale, '')")

    out = run_psql(
        "SELECT "
        + ", ".join(select_items)
        + " FROM pg_database d "
        "JOIN pg_roles r ON r.oid = d.datdba "
        "JOIN pg_tablespace t ON t.oid = d.dattablespace "
        f"WHERE d.datname = {qstr(database)}"
    ).strip()

    if not out:
        raise RuntimeError(f"データベース {database} の属性を取得できませんでした。")

    parts = out.split("\t")
    minimum_len = 5
    if len(parts) < minimum_len:
        raise RuntimeError(f"データベース {database} の属性の形式が不正です。")

    defaults = {
        "encoding": parts[0],
        "lc_collate": parts[1],
        "lc_ctype": parts[2],
        "owner": parts[3],
        "tablespace": parts[4],
    }

    index = 5
    if "datlocprovider" in optional_cols:
        provider = parts[index]
        if provider == "c":
            defaults["locale_provider"] = "libc"
        elif provider == "i":
            defaults["locale_provider"] = "icu"
        index += 1

    if "daticulocale" in optional_cols:
        icu_locale = parts[index]
        if icu_locale:
            defaults["icu_locale"] = icu_locale

    return defaults


def terminate_database_connections(database):
    run_psql(
        "SELECT pg_terminate_backend(pid) FROM pg_stat_activity "
        f"WHERE datname = {qstr(database)} AND pid <> pg_backend_pid()"
    )


def drop_database(database):
    terminate_database_connections(database)
    run_psql(f"DROP DATABASE IF EXISTS {qident(database)}")


def create_database(database, defaults):
    sql = (
        f"CREATE DATABASE {qident(database)} "
        f"TEMPLATE template0 "
        f"ENCODING {qstr(defaults['encoding'])} "
        f"LC_COLLATE {qstr(defaults['lc_collate'])} "
        f"LC_CTYPE {qstr(defaults['lc_ctype'])}"
    )

    if defaults.get("locale_provider"):
        sql += f" LOCALE_PROVIDER = {defaults['locale_provider']}"
    if defaults.get("icu_locale"):
        sql += f" ICU_LOCALE {qstr(defaults['icu_locale'])}"
    if defaults.get("tablespace"):
        sql += f" TABLESPACE {qident(defaults['tablespace'])}"
    if defaults.get("owner"):
        sql += f" OWNER {qident(defaults['owner'])}"

    run_psql(sql)


def recreate_database(database, defaults):
    drop_database(database)
    create_database(database, defaults)


def clone_database(source_db, target_db):
    params = CONNECTION_ARGS
    env = os.environ.copy()
    if params.get("password"):
        env["PGPASSWORD"] = params["password"]

    dump_cmd = [
        "pg_dump",
        *psql_client_args(params),
        "--format=plain",
        "--no-owner",
        "--no-privileges",
        f"--dbname={source_db}",
    ]
    import_cmd = [
        "psql",
        *psql_client_args(params),
        f"--dbname={target_db}",
        "-v",
        "ON_ERROR_STOP=1",
        "-X",
        "-q",
    ]

    dump_proc = subprocess.Popen(dump_cmd, stdout=subprocess.PIPE, env=env)
    import_proc = subprocess.Popen(import_cmd, stdin=dump_proc.stdout, env=env)
    dump_proc.stdout.close()

    import_rc = import_proc.wait()
    dump_rc = dump_proc.wait()
    if dump_rc != 0 or import_rc != 0:
        raise RuntimeError("pg_dump/psql によるコピーに失敗しました。")


def confirm_or_abort(prompt, auto_yes=False):
    if auto_yes:
        return True
    answer = input(f"{prompt} [y/N]: ").strip().lower()
    if answer != "y":
        print("キャンセルしました。")
        return False
    return True


def ensure_managed(config, database):
    if database not in config["databases"]:
        print(f"{database} は管理されていません。先に init を実行してください。")
        return False
    return True


def init_db(args, config):
    database = args.database
    branch = args.branch

    validate_branch_name(database, branch)
    if database in config["databases"]:
        print(f"{database} はすでに管理されています。")
        return

    if not db_exists(database):
        print(f"データベース {database} が存在しません。")
        return

    snapshot_db = branch_db_name(database, branch)
    if db_exists(snapshot_db):
        print(f"退避DB {snapshot_db} がすでに存在します。init を中止します。")
        return

    source_defaults = get_db_defaults(database)
    create_database(snapshot_db, source_defaults)
    try:
        clone_database(database, snapshot_db)
    except Exception:
        drop_database(snapshot_db)
        raise

    config["databases"][database] = {"current": branch, "branches": [branch]}
    save_config(config)
    print(
        f"{database} を管理下に追加しました。current ブランチ: {branch}。"
        f"初期退避DB {snapshot_db} を作成しました。"
    )


def branch_add(args, config):
    database = args.database
    branch = args.branch

    validate_branch_name(database, branch)
    if not ensure_managed(config, database):
        return

    if branch in config["databases"][database]["branches"]:
        print(f"ブランチ {branch} はすでに存在します。")
        return

    snapshot_db = branch_db_name(database, branch)
    if db_exists(snapshot_db):
        print(f"退避DB {snapshot_db} がすでに存在します。")
        return

    source_defaults = get_db_defaults(database)
    create_database(snapshot_db, source_defaults)
    try:
        clone_database(database, snapshot_db)
    except Exception:
        drop_database(snapshot_db)
        raise

    config["databases"][database]["branches"].append(branch)
    save_config(config)
    print(f"ブランチ {branch} を追加しました。{database} のコピーを {snapshot_db} に作成しました。")


def branch_remove(args, config):
    database = args.database
    branch = args.branch

    validate_branch_name(database, branch)
    if not ensure_managed(config, database):
        return

    db_info = config["databases"][database]
    if branch not in db_info["branches"]:
        print(f"ブランチ {branch} は存在しません。")
        return
    if branch == db_info["current"]:
        print("current ブランチは削除できません。")
        return

    if not confirm_or_abort(
        f"ブランチ {branch} の退避DBを削除します。よろしいですか？", args.yes
    ):
        return

    snapshot_db = branch_db_name(database, branch)
    drop_database(snapshot_db)

    db_info["branches"].remove(branch)
    save_config(config)
    print(f"ブランチ {branch} を削除しました。退避DB {snapshot_db} も削除しました。")


def switch_branch(args, config):
    database = args.database
    target_branch = args.branch

    validate_branch_name(database, target_branch)
    if not ensure_managed(config, database):
        return

    db_info = config["databases"][database]
    if target_branch not in db_info["branches"]:
        print(f"ブランチ {target_branch} は存在しません。先に branch-add を実行してください。")
        return

    current_branch = db_info["current"]
    if target_branch == current_branch:
        print(f"{target_branch} はすでに current です。")
        return

    target_snapshot = branch_db_name(database, target_branch)
    current_snapshot = branch_db_name(database, current_branch)

    if not db_exists(target_snapshot):
        print(f"退避DB {target_snapshot} が存在しません。")
        return
    if not db_exists(current_snapshot):
        print(f"退避DB {current_snapshot} が存在しません。switch を中止します。")
        return
    if not db_exists(database):
        print(f"論理DB {database} が存在しません。")
        return

    current_defaults = get_db_defaults(database)
    target_defaults = get_db_defaults(target_snapshot)

    recreate_database(current_snapshot, current_defaults)
    clone_database(database, current_snapshot)

    recreate_database(database, target_defaults)
    clone_database(target_snapshot, database)

    db_info["current"] = target_branch
    save_config(config)
    print(
        f"{database} の current を {target_branch} に切り替えました。"
        f"{current_branch} は {current_snapshot} に退避されています。"
    )


def reset_db(args, config):
    database = args.database

    if not ensure_managed(config, database):
        return
    if not confirm_or_abort(
        f"{database} の管理情報を削除します（退避DBは残ります）。よろしいですか？", args.yes
    ):
        return

    del config["databases"][database]
    save_config(config)
    print(f"{database} の管理情報を削除しました。")


def status(args, config):
    database = args.database

    if database not in config["databases"]:
        print(f"{database} は管理されていません。")
        return

    db_info = config["databases"][database]
    print(f"{database} (current: {db_info['current']})")
    print(f"branches: {', '.join(db_info['branches'])}")


def list_databases(config):
    databases = sorted(config["databases"].keys())
    if not databases:
        print("管理対象はありません。")
        return
    for database in databases:
        print(database)


def verify_database(args, config):
    database = args.database
    issues = []

    if database not in config["databases"]:
        issues.append(f"{database} は管理されていません。")
    else:
        db_info = config["databases"][database]
        current = db_info.get("current")
        branches = db_info.get("branches", [])

        if not isinstance(branches, list) or not branches:
            issues.append("branches が空または不正です。")
        else:
            if current not in branches:
                issues.append("current が branches に含まれていません。")
            for branch in branches:
                try:
                    validate_branch_name(database, branch)
                except Exception as e:
                    issues.append(f"ブランチ名が不正です: {branch} ({e})")

    try:
        if not db_exists(database):
            issues.append(f"論理DB {database} が存在しません。")
    except Exception as e:
        issues.append(f"論理DB確認に失敗しました: {e}")

    if database in config["databases"]:
        db_info = config["databases"][database]
        for branch in db_info.get("branches", []):
            snapshot = branch_db_name(database, branch)
            try:
                if not db_exists(snapshot):
                    issues.append(f"退避DB {snapshot} が存在しません。")
                else:
                    get_db_defaults(snapshot)
            except Exception as e:
                issues.append(f"退避DB {snapshot} の確認に失敗しました: {e}")

        try:
            get_db_defaults(database)
        except Exception as e:
            issues.append(f"論理DBの属性取得に失敗しました: {e}")

    if issues:
        for item in issues:
            print(f"ERROR: {item}")
        return False

    print(f"OK: {database} は整合しています。")
    return True


def main():
    parser = argparse.ArgumentParser(
        description="postgres-switch CLI: 論理DB名を固定したまま、ブランチ単位でDB状態を切り替えるツール"
    )
    parser.add_argument("--host")
    parser.add_argument("--port", type=int)
    parser.add_argument("--user")
    parser.add_argument("--password")

    subparsers = parser.add_subparsers(dest="command")

    parser_init = subparsers.add_parser(
        "init",
        help="既存の論理DBを管理下に追加する",
    )
    parser_init.add_argument("--database", required=True, help="論理DB名")
    parser_init.add_argument("--branch", required=True, help="初期 current ブランチ名")

    parser_branch_add = subparsers.add_parser(
        "branch-add",
        help="ブランチを追加し、current のコピーを退避DBとして作成する",
    )
    parser_branch_add.add_argument("--database", required=True, help="対象の論理DB名")
    parser_branch_add.add_argument("--branch", required=True, help="追加するブランチ名")

    parser_branch_remove = subparsers.add_parser(
        "branch-remove",
        help="非 current ブランチを削除し、対応する退避DBも削除する",
    )
    parser_branch_remove.add_argument("--database", required=True, help="対象の論理DB名")
    parser_branch_remove.add_argument("--branch", required=True, help="削除するブランチ名")
    parser_branch_remove.add_argument("--yes", action="store_true")

    parser_switch = subparsers.add_parser("switch", help="current ブランチを切り替える")
    parser_switch.add_argument("--database", required=True, help="対象の論理DB名")
    parser_switch.add_argument("--branch", required=True, help="切替先ブランチ名")

    parser_reset = subparsers.add_parser("reset", help="管理情報を削除する（退避DBは残す）")
    parser_reset.add_argument("--database", required=True, help="対象の論理DB名")
    parser_reset.add_argument("--yes", action="store_true")

    parser_status = subparsers.add_parser("status", help="指定DBの管理状態を表示する")
    parser_status.add_argument("--database", required=True, help="対象の論理DB名")

    parser_verify = subparsers.add_parser("verify", help="指定DBの整合性を検証する")
    parser_verify.add_argument("--database", required=True, help="対象の論理DB名")

    subparsers.add_parser("list", help="管理対象の論理DB名を一覧表示する")

    args = parser.parse_args()
    global CONNECTION_ARGS
    CONNECTION_ARGS = {
        "host": args.host,
        "port": args.port,
        "user": args.user,
        "password": args.password,
    }

    if args.command in {"init", "branch-add", "branch-remove", "switch", "verify"}:
        ensure_required_commands()

    config = load_config()

    try:
        write_commands = {"init", "branch-add", "branch-remove", "switch", "reset"}
        if args.command in write_commands:
            with database_lock(args.database):
                if args.command == "init":
                    init_db(args, config)
                elif args.command == "branch-add":
                    branch_add(args, config)
                elif args.command == "branch-remove":
                    branch_remove(args, config)
                elif args.command == "switch":
                    switch_branch(args, config)
                elif args.command == "reset":
                    reset_db(args, config)
        elif args.command == "status":
            status(args, config)
        elif args.command == "verify":
            ok = verify_database(args, config)
            if not ok:
                sys.exit(1)
        elif args.command == "list":
            list_databases(config)
        else:
            parser.print_help()
    except Exception as e:
        print(f"エラー: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
