#!/usr/bin/env python3
import argparse
import contextlib
import fcntl
import json
import os
import re
import shutil
import subprocess
import sys
import tempfile

CONFIG_PATH = os.path.expanduser("~/.minio-switch.json")
CONFIG_VERSION = 1
REQUIRED_COMMANDS = ("mc",)
BRANCH_PATTERN = re.compile(r"^[a-z0-9-]+$")
LOCK_DIR = os.path.expanduser("~/.minio-switch-locks")


def load_config():
    if not os.path.exists(CONFIG_PATH):
        return {"version": CONFIG_VERSION, "buckets": {}}
    with open(CONFIG_PATH, "r", encoding="utf-8") as f:
        data = json.load(f)
    if "buckets" not in data:
        data["buckets"] = {}
    if "version" not in data:
        data["version"] = CONFIG_VERSION
    return data


def save_config(config):
    config_dir = os.path.dirname(CONFIG_PATH) or "."
    os.makedirs(config_dir, exist_ok=True)
    with tempfile.NamedTemporaryFile(
        "w", encoding="utf-8", dir=config_dir, delete=False
    ) as tf:
        json.dump(config, tf, indent=2, ensure_ascii=False)
        tf.flush()
        os.fsync(tf.fileno())
        temp_path = tf.name
    os.replace(temp_path, CONFIG_PATH)


def lock_name_for_bucket(alias_name, bucket):
    key = f"{alias_name}__{bucket}"
    safe = re.sub(r"[^A-Za-z0-9_.-]", "_", key)
    return os.path.join(LOCK_DIR, f"{safe}.lock")


@contextlib.contextmanager
def bucket_lock(alias_name, bucket):
    os.makedirs(LOCK_DIR, exist_ok=True)
    lock_path = lock_name_for_bucket(alias_name, bucket)
    with open(lock_path, "w", encoding="utf-8") as lf:
        try:
            fcntl.flock(lf.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
        except BlockingIOError:
            raise RuntimeError(
                f"{alias_name}/{bucket} は他の minio-switch プロセスで処理中です。完了後に再実行してください。"
            )
        try:
            yield
        finally:
            fcntl.flock(lf.fileno(), fcntl.LOCK_UN)


def ensure_required_commands():
    missing = [cmd for cmd in REQUIRED_COMMANDS if shutil.which(cmd) is None]
    if missing:
        missing_list = ", ".join(missing)
        raise RuntimeError(
            f"必須コマンドが見つかりません: {missing_list}。MinIO Client(mc) をインストールしてください。"
        )


def run_mc(args):
    result = subprocess.run(["mc", *args], capture_output=True, text=True)
    if result.returncode != 0:
        stderr = result.stderr.strip() or "mc コマンド実行に失敗しました。"
        raise RuntimeError(stderr)
    return result.stdout


def mc_path(alias_name, bucket):
    return f"{alias_name}/{bucket}"


def config_key(alias_name, bucket):
    return f"{alias_name}/{bucket}"


def bucket_exists(alias_name, bucket):
    result = subprocess.run(
        ["mc", "--json", "stat", mc_path(alias_name, bucket)],
        capture_output=True,
        text=True,
    )
    if result.returncode == 0:
        return True

    events = []
    for stream in (result.stdout, result.stderr):
        for line in stream.splitlines():
            line = line.strip()
            if not line:
                continue
            try:
                events.append(json.loads(line))
            except json.JSONDecodeError:
                continue

    for event in events:
        if event.get("status") != "error":
            continue
        error = event.get("error", {})
        cause = error.get("cause", {})
        message = str(error.get("message", ""))
        cause_message = str(cause.get("message", ""))
        merged = f"{message} {cause_message}".lower()
        if "does not exist" in merged or "not exist" in merged or "not found" in merged:
            return False

    detail = (
        result.stderr.strip()
        or result.stdout.strip()
        or f"mc --json stat {mc_path(alias_name, bucket)}"
    )
    raise RuntimeError(f"バケット存在確認に失敗しました: {detail}")


def ensure_bucket(alias_name, bucket):
    if not bucket_exists(alias_name, bucket):
        run_mc(["mb", mc_path(alias_name, bucket)])


def clone_bucket(source_alias, source_bucket, target_alias, target_bucket):
    source = mc_path(source_alias, source_bucket)
    target = mc_path(target_alias, target_bucket)
    run_mc(["mirror", "--overwrite", "--remove", source, target])


def drop_bucket(alias_name, bucket):
    run_mc(["rb", "--force", mc_path(alias_name, bucket)])


def validate_branch_or_abort(branch):
    if not BRANCH_PATTERN.fullmatch(branch):
        print("branch 名は小文字英数字とハイフンのみ使用できます（正規表現: ^[a-z0-9-]+$）。")
        return False
    return True


def snapshot_bucket_name(bucket, branch):
    snapshot = f"{bucket}--{branch}"
    if len(snapshot) > 63:
        raise RuntimeError(
            f"退避バケット名が長すぎます: {snapshot}。bucket と branch を短くしてください。"
        )
    return snapshot


def confirm_or_abort(prompt, auto_yes=False):
    if auto_yes:
        return True
    answer = input(f"{prompt} [y/N]: ").strip().lower()
    if answer != "y":
        print("キャンセルしました。")
        return False
    return True


def ensure_managed(config, alias_name, bucket):
    key = config_key(alias_name, bucket)
    if key not in config["buckets"]:
        print(f"{key} は管理されていません。先に init を実行してください。")
        return None
    return key


def init_bucket(args, config):
    alias_name = args.alias
    bucket = args.bucket
    branch = args.branch

    if not validate_branch_or_abort(branch):
        return

    key = config_key(alias_name, bucket)
    if key in config["buckets"]:
        print(f"{key} はすでに管理されています。")
        return

    if not bucket_exists(alias_name, bucket):
        print(f"バケット {mc_path(alias_name, bucket)} が存在しません。")
        return

    snapshot = snapshot_bucket_name(bucket, branch)
    if bucket_exists(alias_name, snapshot):
        print(f"退避バケット {mc_path(alias_name, snapshot)} がすでに存在します。")
        return

    ensure_bucket(alias_name, snapshot)
    try:
        clone_bucket(alias_name, bucket, alias_name, snapshot)
    except Exception:
        cleanup_error = None
        try:
            drop_bucket(alias_name, snapshot)
        except Exception as e:
            cleanup_error = e
        if cleanup_error is not None:
            print(
                f"WARN: 退避バケット {mc_path(alias_name, snapshot)} のクリーンアップに失敗しました: {cleanup_error}",
                file=sys.stderr,
            )
        raise

    config["buckets"][key] = {
        "current": branch,
        "branches": [branch],
    }
    save_config(config)
    print(
        f"{key} を管理下に追加しました。current ブランチ: {branch}。"
        f"{mc_path(alias_name, bucket)} のコピーを {mc_path(alias_name, snapshot)} に作成しました。"
    )


def branch_add(args, config):
    alias_name = args.alias
    bucket = args.bucket
    branch = args.branch

    if not validate_branch_or_abort(branch):
        return

    key = ensure_managed(config, alias_name, bucket)
    if not key:
        return

    bucket_info = config["buckets"][key]
    if branch in bucket_info["branches"]:
        print(f"ブランチ {branch} はすでに存在します。")
        return

    snapshot = snapshot_bucket_name(bucket, branch)
    if bucket_exists(alias_name, snapshot):
        print(f"退避バケット {mc_path(alias_name, snapshot)} がすでに存在します。")
        return

    ensure_bucket(alias_name, snapshot)
    try:
        clone_bucket(alias_name, bucket, alias_name, snapshot)
    except Exception:
        cleanup_error = None
        try:
            drop_bucket(alias_name, snapshot)
        except Exception as e:
            cleanup_error = e
        if cleanup_error is not None:
            print(
                f"WARN: 退避バケット {mc_path(alias_name, snapshot)} のクリーンアップに失敗しました: {cleanup_error}",
                file=sys.stderr,
            )
        raise

    bucket_info["branches"].append(branch)
    save_config(config)
    print(
        f"ブランチ {branch} を追加しました。"
        f"{mc_path(alias_name, bucket)} のコピーを {mc_path(alias_name, snapshot)} に作成しました。"
    )


def branch_remove(args, config):
    alias_name = args.alias
    bucket = args.bucket
    branch = args.branch

    if not validate_branch_or_abort(branch):
        return

    key = ensure_managed(config, alias_name, bucket)
    if not key:
        return

    bucket_info = config["buckets"][key]
    if branch not in bucket_info["branches"]:
        print(f"ブランチ {branch} は存在しません。")
        return
    if branch == bucket_info["current"]:
        print("current ブランチは削除できません。")
        return

    snapshot = snapshot_bucket_name(bucket, branch)
    if not confirm_or_abort(
        f"ブランチ {branch} の退避バケットを削除します。よろしいですか？", args.yes
    ):
        return

    if bucket_exists(alias_name, snapshot):
        run_mc(["rb", "--force", mc_path(alias_name, snapshot)])

    bucket_info["branches"].remove(branch)
    save_config(config)
    print(f"ブランチ {branch} を削除しました。退避バケット {snapshot} も削除しました。")


def switch_branch(args, config):
    alias_name = args.alias
    bucket = args.bucket
    target_branch = args.branch

    if not validate_branch_or_abort(target_branch):
        return

    key = ensure_managed(config, alias_name, bucket)
    if not key:
        return

    bucket_info = config["buckets"][key]
    if target_branch not in bucket_info["branches"]:
        print(f"ブランチ {target_branch} は存在しません。先に branch-add を実行してください。")
        return

    current_branch = bucket_info["current"]
    if target_branch == current_branch:
        print(f"{target_branch} はすでに current です。")
        return

    current_snapshot = snapshot_bucket_name(bucket, current_branch)
    target_snapshot = snapshot_bucket_name(bucket, target_branch)

    if not bucket_exists(alias_name, current_snapshot):
        print(
            f"退避バケット {mc_path(alias_name, current_snapshot)} が存在しません。"
            "先に init を実行してください。"
        )
        return
    if not bucket_exists(alias_name, target_snapshot):
        print(f"退避バケット {mc_path(alias_name, target_snapshot)} が存在しません。")
        return
    if not bucket_exists(alias_name, bucket):
        print(f"論理バケット {mc_path(alias_name, bucket)} が存在しません。")
        return

    clone_bucket(alias_name, bucket, alias_name, current_snapshot)

    clone_bucket(alias_name, target_snapshot, alias_name, bucket)

    bucket_info["current"] = target_branch
    save_config(config)
    print(
        f"{mc_path(alias_name, bucket)} の current を {target_branch} に切り替えました。"
        f"{current_branch} は {mc_path(alias_name, current_snapshot)} に退避されています。"
    )


def reset_bucket(args, config):
    alias_name = args.alias
    bucket = args.bucket

    key = ensure_managed(config, alias_name, bucket)
    if not key:
        return

    if not confirm_or_abort(
        f"{key} の管理情報を削除します（退避バケットは残ります）。よろしいですか？", args.yes
    ):
        return

    del config["buckets"][key]
    save_config(config)
    print(f"{key} の管理情報を削除しました。")


def status(args, config):
    alias_name = args.alias
    bucket = args.bucket
    key = config_key(alias_name, bucket)

    if key not in config["buckets"]:
        print(f"{key} は管理されていません。")
        return

    bucket_info = config["buckets"][key]
    print(f"{key} (current: {bucket_info['current']})")
    print(f"branches: {', '.join(bucket_info['branches'])}")


def list_buckets(config):
    keys = sorted(config["buckets"].keys())
    if not keys:
        print("管理対象はありません。")
        return
    for key in keys:
        print(key)


def verify_bucket(args, config):
    alias_name = args.alias
    bucket = args.bucket
    key = config_key(alias_name, bucket)
    issues = []
    warnings = []

    if key not in config["buckets"]:
        issues.append(f"{key} は管理されていません。")
    else:
        info = config["buckets"][key]
        current = info.get("current")
        branches = info.get("branches", [])

        if not isinstance(branches, list) or not branches:
            issues.append("branches が空または不正です。")
        else:
            if current not in branches:
                issues.append("current が branches に含まれていません。")
            for branch in branches:
                if not BRANCH_PATTERN.fullmatch(branch):
                    issues.append(f"ブランチ名が不正です: {branch}")
                try:
                    snapshot_bucket_name(bucket, branch)
                except Exception as e:
                    issues.append(f"退避バケット名が不正です: {branch} ({e})")

    try:
        if not bucket_exists(alias_name, bucket):
            issues.append(f"論理バケット {mc_path(alias_name, bucket)} が存在しません。")
    except Exception as e:
        issues.append(f"論理バケット確認に失敗しました: {e}")

    if key in config["buckets"]:
        for branch in config["buckets"][key].get("branches", []):
            snapshot = snapshot_bucket_name(bucket, branch)
            try:
                if not bucket_exists(alias_name, snapshot):
                    issues.append(f"退避バケット {mc_path(alias_name, snapshot)} が存在しません。")
            except Exception as e:
                issues.append(f"退避バケット {mc_path(alias_name, snapshot)} の確認に失敗しました: {e}")

    if issues:
        for item in issues:
            print(f"ERROR: {item}")
    if warnings:
        for item in warnings:
            print(f"WARN: {item}")
    if not issues and not warnings:
        print(f"OK: {key} は整合しています。")
    elif not issues:
        print(f"OK: {key} は利用可能です（警告あり）。")

    return len(issues) == 0


def main():
    parser = argparse.ArgumentParser(
        description="minio-switch CLI: 論理バケット名を固定したまま、ブランチ単位で状態を切り替えるツール"
    )
    parser.add_argument(
        "--alias",
        default="local",
        help="mc に設定済みの MinIO alias 名（既定: local）",
    )

    subparsers = parser.add_subparsers(dest="command")

    parser_init = subparsers.add_parser("init", help="既存の論理バケットを管理下に追加する")
    parser_init.add_argument("--bucket", required=True, help="論理バケット名")
    parser_init.add_argument(
        "--branch",
        required=True,
        help="初期 current ブランチ名（許可: 小文字英数字とハイフン）",
    )

    parser_branch_add = subparsers.add_parser(
        "branch-add",
        help="ブランチを追加し、current のコピーを退避バケットとして作成する",
    )
    parser_branch_add.add_argument("--bucket", required=True, help="対象の論理バケット名")
    parser_branch_add.add_argument(
        "--branch",
        required=True,
        help="追加するブランチ名（許可: 小文字英数字とハイフン）",
    )

    parser_branch_remove = subparsers.add_parser(
        "branch-remove",
        help="非 current ブランチを削除し、対応する退避バケットも削除する",
    )
    parser_branch_remove.add_argument("--bucket", required=True, help="対象の論理バケット名")
    parser_branch_remove.add_argument(
        "--branch",
        required=True,
        help="削除するブランチ名（許可: 小文字英数字とハイフン）",
    )
    parser_branch_remove.add_argument("--yes", action="store_true")

    parser_switch = subparsers.add_parser("switch", help="current ブランチを切り替える")
    parser_switch.add_argument("--bucket", required=True, help="対象の論理バケット名")
    parser_switch.add_argument(
        "--branch",
        required=True,
        help="切替先ブランチ名（許可: 小文字英数字とハイフン）",
    )

    parser_reset = subparsers.add_parser("reset", help="管理情報を削除する（退避バケットは残す）")
    parser_reset.add_argument("--bucket", required=True, help="対象の論理バケット名")
    parser_reset.add_argument("--yes", action="store_true")

    parser_status = subparsers.add_parser("status", help="指定バケットの管理状態を表示する")
    parser_status.add_argument("--bucket", required=True, help="対象の論理バケット名")

    parser_verify = subparsers.add_parser(
        "verify",
        help="指定バケットの整合性を検証する",
    )
    parser_verify.add_argument("--bucket", required=True, help="対象の論理バケット名")

    subparsers.add_parser("list", help="管理対象の論理バケット名を一覧表示する")

    args = parser.parse_args()

    if args.command in {"init", "branch-add", "branch-remove", "switch", "verify"}:
        ensure_required_commands()

    config = load_config()

    try:
        write_commands = {"init", "branch-add", "branch-remove", "switch", "reset"}
        if args.command in write_commands:
            with bucket_lock(args.alias, args.bucket):
                if args.command == "init":
                    init_bucket(args, config)
                elif args.command == "branch-add":
                    branch_add(args, config)
                elif args.command == "branch-remove":
                    branch_remove(args, config)
                elif args.command == "switch":
                    switch_branch(args, config)
                elif args.command == "reset":
                    reset_bucket(args, config)
        elif args.command == "status":
            status(args, config)
        elif args.command == "verify":
            ok = verify_bucket(args, config)
            if not ok:
                sys.exit(1)
        elif args.command == "list":
            list_buckets(config)
        else:
            parser.print_help()
    except Exception as e:
        print(f"エラー: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
